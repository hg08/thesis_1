\chapter{}\label{CHAPETR_A}
\section{Proof of HK theorem} \label{proof_HK}
The Hohenberg-Kohn theorem: The density $n({\bf r})$ of a nondegenerate ground state uniquely determines the external potential $V({\bf r})$ up to an arbitrary constant.

Proof:
Consider the subset $\mathscr{\nu}\subset L^{\frac{3}{2}}+L^{\infty}$ of potential that yields a normalizable nondegenerate ground state. The solution of the Schrodinger equation provides us with a mapping from the external potential to the ground state wavefunction
\begin{equation}
 v(\vec {\bf r})\rightarrow |\Psi[v]\rangle.
\end{equation}
Since nondegenerate ground state, $|\Psi[v]\rangle$ is uniquely determined apart from a trival phase factor.
Thus we have established a map $C: \mathscr{\nu}\rightarrow \Phi$, where $\Phi$ is the set of ground states.
(1) We can prove that $C$ is invertible. Suppose that $|\Psi_1\rangle$ and $|\Psi_2\rangle$ (They are functions in Sobolev space, i.e.,  $|\Psi_1\rangle, |\Psi_2\rangle \in \mathscr{H}^1(R^{3N})$.) correspond to external potential $v_1$ and $v_2 \in L^{\infty}+L^{\frac{3}{2}}$. Here, $v_1 \neq v_2+\text{C}$. If we assume that $|\Psi_1\rangle=|\Psi_2\rangle=|\Psi\rangle$, by subtraction of Hamiltonian for  $|\Psi_1\rangle$ and $|\Psi_2\rangle$, we find
\begin{equation}
 (v_1-v_2)|\Psi\rangle = (E_1-E_2)|\Psi\rangle
\label{subtraction}
 \end{equation}
If $v_1-v_2$ is  not constant in some region then $\Psi$ must vanish in this region for the above equation(~\ref{subtraction})
to be true. However, if $v_1, v_2 \in L^{\infty}+L^{\frac{3}{2}}$, then $|\Psi\rangle$ cannot vanish on a open set by the unique continuation theorem. Therefore, we obtain a contradiction and hence the assumption we made is wrong. Therefore, $\Psi_1 \neq \Psi_2$ and we obtain the result that different potentials (more than a constant) give different wavefunctions.  So we find that the map $C: \mathscr{\nu}\rightarrow \Phi$ is invertible.

Define the set $A$ as the set of densities which come from a nondegenerate ground state (we only consider the ground 
state densities from potentials in the set $L^{\infty}+L^{\frac{3}{2}}$). The set $A$ is obviously a subset of $S$:
\begin{equation}
S=\{n|n({\bf r})\geq0, \sqrt{n}\in H^1(R^3), \int d^3rn({\bf r})=N\} .
\end{equation}

The electron density $n({\bf r})$ is obtained from the many body wavefuction, which is usually the ground state wavefunction of Hamiltonian $H_v={\hat T}+\hat V+ \hat W$, by
\begin{equation}
 n({\bf r_1})=\langle\Phi |\hat n({\bf r_1})|\Phi\rangle = N\sum_{\sigma_1...\sigma_N}\int d^3_{r_1}...d^3_{r_N}|\Phi({\bf r}_1\sigma_1,...,{\bf r}_N\sigma_N)|.
\label{density}
\end{equation}
According to eqn.(~\ref{density}),from a given wavefunction in the set of ground states $\Phi$,  we can calculate the density.
This provides us a second map $D:\Phi \rightarrow A$ from ground state wavefunctions to ground state densities. To show this we calculate 
\begin{eqnarray}
E[v_1] &=& \langle\Psi[v_1]|\hat T + \hat V_1 +\hat W|\Psi[v_1]\rangle \nonumber\\  
           &<& \langle\Psi[v_2]|\hat T + \hat V_1 +\hat W|\Psi[v_2]\rangle \nonumber \\
           &=&  \langle\Psi[v_2]|\hat T + \hat V_2 +\hat W|\Psi[v_2]\rangle +\int n_2({\bf r})(v_1({\bf r})-v_2({\bf r}))d{\bf r} \nonumber\\
           &=&  E[v_2] +\int n_2({\bf r})(v_1({\bf r})-v_2({\bf r}))d{\bf r} \label{Ev1}.
           \end{eqnarray}
Likewise, we find
\begin{equation}
E[v_2]<  E[v_1] +\int n_1({\bf r})(v_2({\bf r})-v_1({\bf r}))d{\bf r} \label{Ev2}.
\end{equation}
 Using (~\ref{Ev1})+(~\ref{Ev2}), we have
 \begin{equation}
  \int (n_2({\bf r})-n_1({\bf r}))(v_1({\bf r})-v_2({\bf r}))d{\bf r} < 0.
 \end{equation}
If we assume $n_2=n_1$, then obtain contradiction $0<0$, and we conclude that: different ground states must yield
different densities, i.e., $D$ is also invertible. Therefore, the map $DC: \nu \rightarrow A$ is also invertible and the density therefore uniquely determines the external potential. The HK theorem is proved.

%\lstset{backgroundcolor=\color{lightgray}}
\section{AIMD Input Files}
In the thesis, the DFT calculations were done with the CP2K program, which incorporates the Gaussian and plane waves (GPW) method\cite{GL99}. Core electrons were described by Goedecker-Teter-Hutter pseudopotentials\cite{MK05}, while the valence electrons were expanded as a double-zeta Gaussian basis set.
The keyword ''CUTOFF'' defines the planewave cutoff (default unit is in Ry) for the finest level of the multi-grid. 
The higher the planewave cutoff, the finer the grid.
Having constructed the multi-grid, QUICKSTEP then map the Gaussians onto the grids. The keyword ''REL$\_$CUTOFF'' controls which product Gaussians 
are mapped onto which level of the multi-grid. CP2K tries to map each Gaussian onto a grid such that the number of grid points 
covered by the Gaussian—no matter how wide or narrow—are roughly the same. ''REL$\_$CUTOFF'' defines the planewave cutoff of a reference grid 
covered by a Gaussian with unit standard deviation $e^{|\vec r|^2}$.\cite{CP2K}

Therefore, the two most important keywords effecting the integration grid and the accuracy of a calculation are ''CUTOFF'' and ''REL$\_$CUTFF''.
If ''CUTOFF'' is too low, then all grids will be coarse and the calculation may become inaccurate; and if REL$\_$CUTOFF is too low, then even if you have a high ''CUTOFF'', 
all Gaussians will be mapped onto the coarsest level of the multi-grid, and thus the effective integration grid for the calculation may still be too coarse.

The CP2K input file for the system of vapor-water interface is as follows. 
% backgroundcolor=\color{lightgray},
\begin{lstlisting}[
                  language=C]                  ]
#name of the input file: inp4
&FORCE_EVAL
  METHOD QS
  &DFT
    BASIS_SET_FILE_NAME ./BASIS_MOLOPT   
    POTENTIAL_FILE_NAME ./GTH_POTENTIALS
    &MGRID
      CUTOFF 280
    &END MGRID
    &QS
      EPS_DEFAULT 1.0E-12
      WF_INTERPOLATION PS 
      EXTRAPOLATION_ORDER 3
    &END QS
    &SCF

      &OT ON
      #MINIMIZER DIIS
      &END OT
     SCF_GUESS        RESTART
     #SCF_GUESS ATOMIC
     EPS_SCF     1.0E-6
     MAX_SCF 300

    &END SCF
    &XC
      &XC_FUNCTIONAL BLYP  
      &END XC_FUNCTIONAL
      &vdW_POTENTIAL
         DISPERSION_FUNCTIONAL PAIR_POTENTIAL
         &PAIR_POTENTIAL
            TYPE DFTD3
            CALCULATE_C9_TERM .TRUE.
            REFERENCE_C9_TERM .TRUE.
            LONG_RANGE_CORRECTION .TRUE.
            PARAMETER_FILE_NAME ./dftd3.dat
            REFERENCE_FUNCTIONAL BLYP 
            R_CUTOFF 8.
            EPS_CN 0.01
         &END PAIR_POTENTIAL
      &END vdW_POTENTIAL
    &END XC
  &END DFT
  &SUBSYS
    &CELL
      ABC 10.00 10.00 40.0
    &END CELL
    #input coords from an equilibrated structure 
    &COORD
      @INCLUDE 'pos.inc'  #pos.inc is the coordinates of the system
    &END COORD
    &KIND H
      BASIS_SET DZVP-MOLOPT-SR-GTH
      POTENTIAL GTH-BLYP-q1
    &END KIND
    &KIND O
      BASIS_SET DZVP-MOLOPT-SR-GTH
      POTENTIAL GTH-BLYP-q6
    &END KIND
    &KIND I 
      BASIS_SET DZVP-MOLOPT-SR-GTH
      POTENTIAL GTH-BLYP-q7
    &END KIND
    &KIND Na 
      BASIS_SET DZVP-MOLOPT-SR-GTH
      POTENTIAL GTH-BLYP-q9                        
    &END KIND
  &END SUBSYS
&END FORCE_EVAL
&GLOBAL
  PROJECT 63wat
  RUN_TYPE MD        
  PRINT_LEVEL LOW
&END GLOBAL

&MOTION
  &GEO_OPT
    TYPE minimization
    OPTIMIZER BFGS
    MAX_ITER 20
  &END GEO_OPT

  &MD
    &THERMOSTAT
      &NOSE
        LENGTH 3
        YOSHIDA 3
        TIMECON 1000.
        MTS 2
      &END NOSE
    &END THERMOSTAT
    ENSEMBLE NVT
    STEPS 1000000
    TIMESTEP 0.5
    TEMPERATURE 300.0
    TEMP_TOL 60
  &END MD

  &PRINT
   &TRAJECTORY
     &EACH
       MD 1
     &END EACH
   &END TRAJECTORY
   &VELOCITIES ON
     &EACH
       MD 1
     &END EACH
   &END VELOCITIES
   &FORCES ON
     &EACH
       MD 1
     &END EACH
   &END FORCES

   &RESTART_HISTORY
     &EACH
       MD 1000
     &END EACH
   &END RESTART_HISTORY
   &RESTART
     BACKUP_COPIES 1
     &EACH
       MD 1
     &END EACH
   &END RESTART
  &END PRINT
&END MOTION
 \end{lstlisting}

\section{Extract the Molecules from Instantaneous Interface}
The structure of the program is as follows.
The aim of the program is:
1) determine the instananeous interface of a system.
2) print the atomic indices of atoms which are near the instananeous interface.
3) print all the atomic indices of molecules which are near the instananous interface.

\paragraph{Extracting O bonded to H} \label{Extracting O bonded to H}
For the alkali nitrate solution/vapor interface system , if we only analyz properties of water molecules, we need to exclude \nitrate in the calculation of VDOS, i.e., we do not print the atomic indices of O atoms which are not in a water molecule. Here is one general algorithm. 
% backgroundcolor=\color{lightgray},  
\begin{lstlisting}[                                                                                          
                  language=python]
#=================
#From chandler3.py
#=================
for at in range(nb_atoms):
    if at not in [1,2,3]:
        if lsymb[at].number == 8:
            good_Oss=False #Test value, to know if the studied O is good 

            #Conversion of the (y,z) coordinates of O into (j,k)
            i=math.floor(lx[at]/divx)
            j=math.floor(ly[at]/divy)
            k=math.floor(lz[at]/divz)

            if n_axis ==0:
                #Comparison between the distance of O to surf1 and surf2 with the default thickness
                #if the O is far away from the surfaces, then we print it
                if surf1[nb_divz*j+k]+thickness <= lx[at] and surf2[nb_divz*j+k]-thickness >= lx[at]:
                    file_o1.write(str(at+1)+' ')
                    print (at+1, " ", end="")
                    good_Oss=True

                elif n_axis ==1:
                    if surf1[nb_divz*i+k]+thickness <= ly[at] and  surf2[nb_divz*i+k]-thickness >= ly[at]:
                        file_o1.write(str(at+1)+' ')
                        print (at+1, " ", end="")
                        good_Oss=True
                else:
                    if surf1[nb_divy*i+j]+thickness <= lz[at] and surf2[nb_divy*i+j]-thickness >= lz[at]:
                        file_o1.write(str(at+1)+' ')
                        print (at+1, " ", end="")
                        good_Oss=True
#====================================================
\end{lstlisting}
%
However, this code is not a general one! 
We used the statement \texttt{if at not in [1,2,3]:}. 
This works because this is a special case, and then we easily know 
that the atoms with index 1, 2, and 3 are the O atoms which are not bonded to H atoms. 
Our aim is to find a general cirterion to judge whether there is a O-H bond exists for any O atom. 
I put the method in the following parts.

\paragraph{chandler3\_1.py}     \label{chandler3_1}
The function \texttt{chandler3\_1.py} can be used to extract the O atoms bonded to H atoms in water molecules, with the definition of the list \texttt{list\_O1} and 
the maximal lengh of the O-N bond \texttt{max\_dist\_no}. This is more general than the above one in ~\ref{Extracting O bonded to H} .
%\begin{widetext}
%\lstset{language=Python}
% backgroundcolor=\color{lightgray},
\begin{lstlisting}[ language=python]
#Filename: chandler3.py 
#To run this function: python3.2 chandler3.py
import periodictable
import math 

#=========
#CONSTANTS
#=========
atob=1.88971616463 #Factor to convert from Ang to bohr
dim = 3
xi = 2.4 # Angstrom
xi2_2 = 2*xi**2
xi2_9 = 9*xi**2
norm = (2*math.pi*xi**2)**(-dim/2)
rho_ref=0.016
max_dist=1.2#Maximal length of the O-H bond
max_dist2= max_dist**2
max_dist_no= 1.4  #Maximal lengh of the O-N bond
max_dist2_no= max_dist_no**2  #Maximal lengh of the O-N 

#===========
#SUBROUTINES
#===========
#Calculate the density associated with one O on a grid point
#Pbc are taken into account
#If distance higher than 3xi we do not take it into account
def density(x,y,z,a,b,c,range_x,range_y,range_z): 
	d=0
	for i in range(-range_x,range_x+1): 
		for j in range(-range_y,range_y+1): 
			for k in range(-range_z,range_z+1):

				r2=(x-a*i)**2+(y-b*j)**2+(z-c*k)**2 
				#The atoms which are to far away (more than 3*xi) are not taken into account
				if r2 <xi2_9:
					d+= math.exp(-r2/xi2_2) #1 op

	return d 

#This subroutine determines the position of rho_ref on the grid
#and returns it. 
def pos_surf(start,end,step,rho,itoc):
	#Fist grid point with rho>rho_ref
	for i in range(start,end,step):
		if rho[i] >= rho_ref:
			break
	if i==end-1:#Protection if there is a hole in the slab (low density along the normal axis)
		j=i+step
	else:
		#First grid point after the water slab with rho<rho_ref
		for j in range(i+step,end,step):
			if rho[j] <= rho_ref :
				break

	#Linear interpolation of the surface position 
	#1)Interpolation between i and i-1
	z1= (rho_ref-rho[i])/(rho[i]-rho[i-step])+i
	z1= (z1-start)/step*itoc
	#2)Interpolation between j-1 and j
	z2= (rho_ref-rho[j])/(rho[j]-rho[j-step])+j
	z2 =(z2-start)/step*itoc
	
	return z1,z2

#===============
#Basic questions
#===============
name=input("What is the name of the position file? (input)\n")
file_i = open(name,"r")
line=input("What are the crystal parameters? (a b c in Ang)\n")
line_split=line.split(' ')
a=float(line_split[0])
b=float(line_split[1])
c=float(line_split[2])

whish_size=float(input("What is aproximatively the size of a grid division? (in Ang)\n"))

thickness=float(input("What is the thickness of your surface? (in Ang)\n"))

n_axis=int(input("What is the normal axis? (0->x, 1->y, 2->z)\n"))

name_split=name.split('.')
name0=name_split[0]+'.cube'
file_o = open(name0, 'w') #the cube file as output

name1 = 'surf_'+ name_split[0]+'.dat' 
file_o1 = open(name1, 'w') #store the atomic indices into file_o1
#END OF QUESTIONS

#================================================
#Reading the main information
nb_atoms=int(file_i.readline()) #Number of atoms


#================================================
#The first 2 lines of the cube file are written
file_o.write("cube file for determining the isosurface of a system.\n")
file_o.write("OUTER LOOP: X, MIDDLE LOOP: Y, INNER LOOP: Z\n")

#================================================
#The 3rd line of the cube file are written
#{0:5d} means: the data number 0 is an integer and will be printed with 5 digits
#{1:12.6f} means: the data number 1 is float and will be printed with 12 digits whom 6 will be after the .
file_o.write("{0:5d} {1:12.6f} {2:12.6f} {3:12.6f}\n".format(nb_atoms,0,0,0))

#=============================
#the 4th line of the cube file
#Definition of the grid
#=============================

nb_divx=round(a/whish_size) 
nb_divy=round(b/whish_size) 
nb_divz=round(c/whish_size) 
divx=a/nb_divx
divy=b/nb_divy
divz=c/nb_divz
file_o.write("{0:5d} {1:12.6f} {2:12.6f} {3:12.6f}\n".format(nb_divx,divx*atob,0        ,0))
file_o.write("{0:5d} {1:12.6f} {2:12.6f} {3:12.6f}\n".format(nb_divy,0        ,divy*atob,0))
file_o.write("{0:5d} {1:12.6f} {2:12.6f} {3:12.6f}\n".format(nb_divz,0        ,0        ,divz*atob))
#Calculation of the number of boxes to take into account
#Depends on :
#     1)the orientation of the normal axis
#     2)the ratio between the cell parameters and 3xi
if n_axis == 0:
	range_x=0
	range_y=math.ceil(3*xi/b)
	range_z=math.ceil(3*xi/c)
elif n_axis ==1:
	range_x=math.ceil(3*xi/a) 
	range_y=0
	range_z=math.ceil(3*xi/c)
	
else :
	range_x=math.ceil(3*xi/a)
	range_y=math.ceil(3*xi/b)
	range_z=0
	
#========================================
#nb_atoms lines about the atomic position
#atomic_number   random_float    x   y  z
#========================================
#Skip the commentary line of the xyz file
file_i.readline()

#1)Read all the atomic positions (and symbol)
#and calculate the position of the mass center
lsymb = [None]*nb_atoms
lx = [None]*nb_atoms
ly = [None]*nb_atoms
lz = [None]*nb_atoms
sum_mass=0
center_pos=0
for i in range(nb_atoms):

#	print(file_i.readline().split())
	symb,x,y,z=file_i.readline().split()

	#Record the values inside a list with good format
	lsymb[i]=periodictable.elements.symbol(symb)#lsymb is an object
	lx[i]=float(x)
	ly[i]=float(y)
	lz[i]=float(z)
	
	#Calculate the mass center along the normal axis
	if n_axis==0:
                center_pos += lx[i]*lsymb[i].mass
	elif n_axis==1:
                center_pos += ly[i]*lsymb[i].mass
	else: 
		center_pos += lz[i]*lsymb[i].mass
	sum_mass +=lsymb[i].mass 

center_pos/=sum_mass

#2)Recenter (along the normal axis only) the atoms according to the mass center
if n_axis==0:
	for i in range(nb_atoms):
		lx[i]=lx[i]-center_pos +a/2
elif n_axis ==1:
	for i in range(nb_atoms):
		ly[i]=ly[i]-center_pos +b/2
else:
	for i in range(nb_atoms):
		lz[i]=lz[i]-center_pos +c/2

#3)Recenter all the atoms inside the cell (along all the directions)
#and write the data
for i in range(nb_atoms):
	lx[i]=lx[i]%a ; ly[i]=ly[i]%b ; lz[i]=lz[i]%c
	file_o.write(" {0:5d} {1:12.6f} {2:12.6f} {3:12.6f} {4:12.6f}\n".format(lsymb[i].number,0,lx[i]*atob,ly[i]*atob,lz[i]*atob))

#===============
#Volumetric data
#===============
inc=0
rho=[0]*nb_divx*nb_divy*nb_divz
#Loop for the grid
for i in range (nb_divx): #The program starts with this line
	for j in range(nb_divy):
		for k in range(nb_divz):
			#Sum over all the O
			for at in range(nb_atoms):
				if lsymb[at].number == 8:#Only the O are selected
					rho[inc]+=density(lx[at]-(i+0.5)*divx, ly[at]-(j+0.5)*divy,lz[at]-(k+0.5)*divz,a,b,c,range_x,range_y,range_z)
			rho[inc] *= norm


			file_o.write(" {0:12.6f}".format(rho[inc]))
			inc+=1
			if k % 6 == 5:
				file_o.write("\n")
		if k%6 != 5:
			file_o.write("\n")

#====================
#Determine isosurface
#====================
inc =0
if n_axis==0:
	surf1=[0]*nb_divy*nb_divz#Initialization of the list associated with the perpendicular plane
	surf2=[0]*nb_divy*nb_divz
	#For each point of this plane, the point where the reference density is reached is calculated (and stored inside surf1 surf2)
	for j in range(nb_divy):
		for k in range(nb_divz):
			start_inc= k+nb_divz*j
			step_inc = nb_divz*nb_divy
			end_inc  = start_inc+step_inc*nb_divx
			surf1[inc],surf2[inc] =pos_surf(start_inc, end_inc, step_inc, rho,divx)#This function calculates the position of the reference density
			#print(start_inc, step_inc, end_inc)
			#print(surf1[inc])
			inc += 1
elif n_axis ==1:
	surf1=[0]*nb_divx*nb_divz
	surf2=[0]*nb_divx*nb_divz
	for i in range(nb_divx):
		for k in range(nb_divz):
			start_inc= k+nb_divz*(nb_divy*i)
			step_inc = nb_divz
			end_inc  = start_inc+step_inc*nb_divy
			surf1[inc],surf2[inc] =pos_surf(start_inc, end_inc, step_inc, rho,divy)
			#print(start_inc, step_inc, end_inc)
			#print(surf1[inc])
			inc += 1
else:
	surf1=[0]*nb_divx*nb_divy
	surf2=[0]*nb_divx*nb_divy
	for i in range(nb_divx):
		for j in range(nb_divy):
			start_inc= nb_divz*(j+nb_divy*i)
			step_inc = 1
			end_inc  = start_inc+step_inc*nb_divz
			surf1[inc],surf2[inc]=pos_surf(start_inc, end_inc, step_inc, rho,divz)
			#print(start_inc, step_inc, end_inc)
			#print(surf1[inc],surf2[inc])
			inc += 1

#==================================================
#Determine the atoms which are close to the surface
#and print their index
#==================================================
list_O1=[-1]
for at in range(nb_atoms):
	if lsymb[at].number == 8:
		for at1 in range(nb_atoms): 
			if lsymb[at1].number != 8:  #To avoid the O atoms itself as at and at1 [at-the-same-time]  
				if (lx[at1]-lx[at])**2 + (ly[at1]-ly[at])**2 +(lz[at1]-lz[at])**2 <= max_dist2_no and lsymb[at1].number !=1:
					list_O1.append(at)
					#print(list_O1) #for testing
file_o1.write('surface 1:\n')
for at in range(nb_atoms):
	if lsymb[at].number == 8:
		if at not in list_O1:
			good_O=False #Test value, to know if the studied O is good 

			#Conversion of the (y,z) coordinates of O into (j,k)
			i=math.floor(lx[at]/divx)
			j=math.floor(ly[at]/divy)
			k=math.floor(lz[at]/divz)

			if n_axis ==0:
				#Comparison between the distance of O to surf1 with the default thickness
				#if the O is close to the surface, then we print it
				if surf1[nb_divz*j+k]+thickness >= lx[at]:
					file_o1.write(str(at+1)+' ')
					print (at+1, " ", end="")
					good_O=True

			elif n_axis ==1:
				if surf1[nb_divz*i+k]+thickness >= ly[at]:
					file_o1.write(str(at+1)+' ')
					print (at+1, " ", end="")
					good_O=True
			else:
				if surf1[nb_divy*i+j]+thickness >= lz[at]:
					file_o1.write(str(at+1)+' ')
					print (at+1, " ", end="")
					good_O=True


			#If the O is close to the surface (good_O=True)
			#Therefore, the H close to him are printed too             
			if good_O:
				for at2 in range(nb_atoms):                                    
					if lsymb[at2].number ==1: 
						if (lx[at2]-lx[at])**2 + (ly[at2]-ly[at])**2 +(lz[at2]-lz[at])**2 <= max_dist2:                                                                
							file_o1.write(str(at2+1)+' ')
							print(at2+1, " ", end=" ")
file_o1.write('\nsurface 2:\n')
print()
for at in range(nb_atoms):
	if lsymb[at].number == 8:
		if at not in list_O1:
			good_Os=False #Test value, to know if the studied O is good 

			#Conversion of the (y,z) coordinates of O into (j,k)
			i=math.floor(lx[at]/divx)
			j=math.floor(ly[at]/divy)
			k=math.floor(lz[at]/divz)

			if n_axis ==0:
				#Comparison between the distance of O to surf2 with the default thickness
				#if the O is close to the surface, then we print it
				if surf2[nb_divz*j+k]-thickness <= lx[at]:
					file_o1.write(str(at+1)+' ')
					print (at+1, " ", end="")
					good_Os=True

			elif n_axis ==1:
				if surf2[nb_divz*i+k]-thickness <= ly[at]:
					file_o1.write(str(at+1)+' ')
					print (at+1, " ", end="")
					good_Os=True
			else:
				if surf2[nb_divy*i+j]-thickness <= lz[at]:
					file_o1.write(str(at+1)+' ')
					print (at+1, " ", end="")
					good_Os=True


			#If the O s close to the surface (good_Os=True)
			#Therefore, the H close to him are printed too             
			if good_Os:
				for at2 in range(nb_atoms):                                    
					if lsymb[at2].number ==1: 
						if (lx[at2]-lx[at])**2 + (ly[at2]-ly[at])**2 +(lz[at2]-lz[at])**2 <= max_dist2:                                                                
							file_o1.write(str(at2+1)+' ')
							print(at2+1, " ", end=" ")
file_o1.write('\n')
print()

file_o1.write('\nbulk:\n')
print()
for at in range(nb_atoms):
	if lsymb[at].number == 8:
		if at not in list_O1:
			good_Oss=False #Test value, to know if the studied O is good 
			#Conversion of the (y,z) coordinates of O into (j,k)
			i=math.floor(lx[at]/divx)
			j=math.floor(ly[at]/divy)
			k=math.floor(lz[at]/divz)
	
			if n_axis ==0:
				#Comparison between the distance of O to surf1 and surf2 with the default thickness
				#if the O is far away from the surfaces, then we print it
				if surf1[nb_divz*j+k]+thickness <= lx[at] and surf2[nb_divz*j+k]-thickness >= lx[at]:
					file_o1.write(str(at+1)+' ')
					print (at+1, " ", end="")
					good_Oss=True

			elif n_axis ==1:
				if surf1[nb_divz*i+k]+thickness <= ly[at] and  surf2[nb_divz*i+k]-thickness >= ly[at]:
					file_o1.write(str(at+1)+' ')
					print (at+1, " ", end="")
					good_Oss=True
			else:
				if surf1[nb_divy*i+j]+thickness <= lz[at] and surf2[nb_divy*i+j]-thickness >= lz[at]:
					file_o1.write(str(at+1)+' ')
					print (at+1, " ", end="")
					good_Oss=True
			#If the O s close to the surface (good_Os=True)
			#Therefore, the H close to him are printed too             
			if good_Oss:
				for at2 in range(nb_atoms): 
					if lsymb[at2].number ==1: 
						if (lx[at2]-lx[at])**2 + (ly[at2]-ly[at])**2 +(lz[at2]-lz[at])**2 <= max_dist2:                                                                
							file_o1.write(str(at2+1)+' ')
							print(at2+1, " ", end=" ")
file_o1.write('\n')
print()
\end{lstlisting}
%==========
\begin{figure}
\includegraphics [width=0.5\textwidth]{./diagrams/result_chandler3_1}   % Here is how to import EPS art
\caption{\label{fig:criterion} (Color) The consequence of the criterion in \texttt{chandler3\_1.py} for judging the existence of O-H bond in water molecules. This cirterion can extract the O atoms in water molecules, and are satisfying the position criteria (close surface 1, close to surface 2 or in the bulk). }
\end{figure}
%=========

\paragraph{Reduce the parameters}
We need to reduce the number of input parameters as possible as we can! 
%For example,  if we do not care the name of the cube file, we do not need to ask the user to input it. 
%
\lstset{language=Python}
\begin{lstlisting}
#=================
#From chandler3.py
#=================
name=input("What is the name of the position file? (input)\n")
file_i = open(name,"r")
line=input("What are the crystal parameters? (a b c in Ang)\n")
line_split=line.split(' ')
a=float(line_split[0])
b=float(line_split[1])
c=float(line_split[2])

whish_size=float(input("What is aproximatively the size of a grid division? (in Ang)\n"))

thickness=float(input("What is the thickness of your surface? (in Ang)\n"))

n_axis=int(input("What is the normal axis? (0->x, 1->y, 2->z)\n"))

name_split=name.split('.')
name0=name_split[0]+'.cube'
file_o = open(name0, 'w') #the cube file as output

name1 = 'surf_'+ name_split[0]+'.dat'
file_o1 = open(name1, 'w') #store the atomic indices into file_o1
#End of questions
\end{lstlisting}
%===========

Instead, by using the \texttt{split()} function, we extract information from the position file (one input) and then to construct a name of the cube file automatically! This idea makes the program more efficient.

The following is the function to extract the water molecules close to the instantaneous interface. In this function, the O-N distance criterion (O-H distance criterion, or call it \texttt{max\_dist2\_no} criterion) is used to make sure all the O atoms extracted are O atoms in water and not O atoms in other ions (eg. \nitrate). 
The basic idea is: if O-H distance satisfys the criterion, print the index of the O atom.
However, this criterion produces another problem. Because there are two H atoms in a water molecules, it prints atomic indices of O atoms two times.
To remove the repeated atomic indices coming from the \texttt{max\_dist2\_no} criterion. We introduce the \texttt{if at!=test\_Os} part. Here is the code:
%===================
\lstset{language=Python}
\begin{lstlisting}
#================================
#Filename: chandler4_2.py 
#To run: python3.2 chandler4_2.py
#================================

import periodictable
import math 

#=========
#CONSTANTS
#=========
atob=1.88971616463 #Factor to convert from Ang to bohr
dim = 3
xi = 2.4 # Angstrom
xi2_2 = 2*xi**2
xi2_9 = 9*xi**2
norm = (2*math.pi*xi**2)**(-dim/2)
rho_ref=0.016
max_dist=1.2#Maximal length of the O-H bond
max_dist2= max_dist**2
max_dist_no= 1.4  #Maximal lengh of the O-N bond
max_dist2_no= max_dist_no**2  #Maximal lengh of the O-N bond

#===========
#SUBROUTINES
#===========
#Calculate the density associated with one O on a grid point
#Pbc are taken into account
#If distance higher than 3xi we do not take it into account
def density(x,y,z,a,b,c,range_x,range_y,range_z): 
	d=0
	for i in range(-range_x,range_x+1): 
		for j in range(-range_y,range_y+1): 
			for k in range(-range_z,range_z+1):

				r2=(x-a*i)**2+(y-b*j)**2+(z-c*k)**2 
				#The atoms which are to far away (more than 3*xi) are not taken into account
				if r2 <xi2_9:
					d+= math.exp(-r2/xi2_2)   # op

	return d 

#This subroutine determines the position of rho_ref on the grid and returns it. 
def pos_surf(start,end,step,rho,itoc):
	#Fist grid point with rho>rho_ref
	for i in range(start,end,step):
		if rho[i] >= rho_ref:
			break
	if i==end-1:#Protection if there is a hole in the slab (low density along the normal axis)
		j=i+step
	else:
		#First grid point after the water slab with rho<rho_ref
		for j in range(i+step,end,step):
			if rho[j] <= rho_ref :
				break

	#Linear interpolation of the surface position 
	#1)Interpolation between i and i-1
	z1= (rho_ref-rho[i])/(rho[i]-rho[i-step])+i
	z1= (z1-start)/step*itoc
	#2)Interpolation between j-1 and j
	z2= (rho_ref-rho[j])/(rho[j]-rho[j-step])+j
	z2 =(z2-start)/step*itoc
	
	return z1,z2

#===============
#Basic questions
#===============
name=input("What is the name of the position file? (input)\n")
file_i = open(name,"r")
line=input("What are the crystal parameters? (a b c in Ang)\n")
line_split=line.split(' ')
a=float(line_split[0])
b=float(line_split[1])
c=float(line_split[2])

whish_size=float(input("What is aproximatively the size of a grid division? (in Ang)\n"))

thickness=float(input("What is the thickness of your surface? (in Ang)\n"))

n_axis=int(input("What is the normal axis? (0->x, 1->y, 2->z)\n"))

name_split=name.split('.')
name0=name_split[0]+'.cube'
file_o = open(name0, 'w') #the cube file as output

name1 = 'surf_'+ name_split[0]+'.dat' 
file_o1 = open(name1, 'w') #store the atomic indices into file_o1
#End of questions


#================================================
#Reading the main information
nb_atoms=int(file_i.readline()) #Number of atoms


#================================================
#The first 2 lines of the cube file are written
file_o.write("cube file for determining the isosurface of a system.\n")
file_o.write("OUTER LOOP: X, MIDDLE LOOP: Y, INNER LOOP: Z\n")


#=========================================
#The 3rd line of the cube file are written
#{0:5d} means: the data number 0 is an integer and will be printed with 5 digits
#{1:12.6f} means: the data number 1 is float and will be printed with 12 digits whom 6 will be after the .
file_o.write("{0:5d} {1:12.6f} {2:12.6f} {3:12.6f}\n".format(nb_atoms,0,0,0))


#=============================
#the 4th line of the cube file
#Definition of the grid
#=============================
nb_divx=round(a/whish_size) 
nb_divy=round(b/whish_size) 
nb_divz=round(c/whish_size) 
divx=a/nb_divx
divy=b/nb_divy
divz=c/nb_divz
file_o.write("{0:5d} {1:12.6f} {2:12.6f} {3:12.6f}\n".format(nb_divx,divx*atob,0        ,0))
file_o.write("{0:5d} {1:12.6f} {2:12.6f} {3:12.6f}\n".format(nb_divy,0        ,divy*atob,0))
file_o.write("{0:5d} {1:12.6f} {2:12.6f} {3:12.6f}\n".format(nb_divz,0        ,0        ,divz*atob))
#Calculation of the number of boxes to take into account
#Depends on :
#     1)the orientation of the normal axis
#     2)the ratio between the cell parameters and 3xi
if n_axis == 0:
	range_x=0
	range_y=math.ceil(3*xi/b)
	range_z=math.ceil(3*xi/c)
elif n_axis ==1:
	range_x=math.ceil(3*xi/a) 
	range_y=0
	range_z=math.ceil(3*xi/c)
	
else :
	range_x=math.ceil(3*xi/a)
	range_y=math.ceil(3*xi/b)
	range_z=0
	
#========================================
#nb_atoms lines about the atomic position
#atomic_number   random_float    x   y  z
#========================================
#Skip the commentary line of the xyz file
file_i.readline()

# Read all the atomic positions (and symbol) and calculate the position of the mass center
lsymb = [None]*nb_atoms
lx = [None]*nb_atoms
ly = [None]*nb_atoms
lz = [None]*nb_atoms
lx0 = [None]*nb_atoms
ly0 = [None]*nb_atoms
lz0 = [None]*nb_atoms
sum_mass=0
center_pos=0
for i in range(nb_atoms):
	symb,x,y,z=file_i.readline().split()

	#Record the values inside a list with good format
	lsymb[i]=periodictable.elements.symbol(symb)#lsymb is an object
	lx[i]=float(x)
	ly[i]=float(y)
	lz[i]=float(z)
	
	#Calculate the mass center along the normal axis
	if n_axis==0:
                center_pos += lx[i]*lsymb[i].mass
	elif n_axis==1:
                center_pos += ly[i]*lsymb[i].mass
	else: 
		center_pos += lz[i]*lsymb[i].mass
	sum_mass +=lsymb[i].mass 

center_pos/=sum_mass

#2)Recenter (along the normal axis only) the atoms according to the mass center
if n_axis==0:
	for i in range(nb_atoms):
		lx[i]=lx[i]-center_pos +a/2
elif n_axis ==1:
	for i in range(nb_atoms):
		ly[i]=ly[i]-center_pos +b/2
else:
	for i in range(nb_atoms):
		lz[i]=lz[i]-center_pos +c/2

#3)Recenter all the atoms inside the cell (along all the directions)
#and write the data
for i in range(nb_atoms):
	lx[i]=lx[i]%a ; ly[i]=ly[i]%b ; lz[i]=lz[i]%c

	file_o.write(" {0:5d} {1:12.6f} {2:12.6f} {3:12.6f} {4:12.6f}\n".format(lsymb[i].number,0,lx[i]*atob,ly[i]*atob,lz[i]*atob))


#===============
#Volumetric data
#===============
inc=0
rho=[0]*nb_divx*nb_divy*nb_divz
#Loop for the grid
for i in range (nb_divx): #The program starts with this line
	for j in range(nb_divy):
		for k in range(nb_divz):
			#Sum over all the O
			for at in range(nb_atoms):
				if lsymb[at].number == 8:#Only the O are selected
					rho[inc]+=density(lx[at]-(i+0.5)*divx, ly[at]-(j+0.5)*divy,lz[at]-(k+0.5)*divz,a,b,c,range_x,range_y,range_z)
			rho[inc] *= norm


			file_o.write(" {0:12.6f}".format(rho[inc]))
			inc+=1
			if k % 6 == 5:
				file_o.write("\n")
		if k%6 != 5:
			file_o.write("\n")


#====================
#Determine isosurface
#====================
inc =0
if n_axis==0:
	surf1=[0]*nb_divy*nb_divz#Initialization of the list associated with the perpendicular plane
	surf2=[0]*nb_divy*nb_divz
	#For each point of this plane, the point where the reference density is reached is calculated (and stored inside surf1 surf2)
	for j in range(nb_divy):
		for k in range(nb_divz):
			start_inc= k+nb_divz*j
			step_inc = nb_divz*nb_divy
			end_inc  = start_inc+step_inc*nb_divx
			surf1[inc],surf2[inc] =pos_surf(start_inc, end_inc, step_inc, rho,divx)  # The function calculates the position of the reference density
			#print(start_inc, step_inc, end_inc)
			#print(surf1[inc])
			inc += 1
elif n_axis ==1:
	surf1=[0]*nb_divx*nb_divz
	surf2=[0]*nb_divx*nb_divz
	for i in range(nb_divx):
		for k in range(nb_divz):
			start_inc= k+nb_divz*(nb_divy*i)
			step_inc = nb_divz
			end_inc  = start_inc+step_inc*nb_divy
			surf1[inc],surf2[inc] =pos_surf(start_inc, end_inc, step_inc, rho,divy)
			#print(start_inc, step_inc, end_inc)
			#print(surf1[inc])
			inc += 1
else:
	surf1=[0]*nb_divx*nb_divy
	surf2=[0]*nb_divx*nb_divy
	for i in range(nb_divx):
		for j in range(nb_divy):
			start_inc= nb_divz*(j+nb_divy*i)
			step_inc = 1
			end_inc  = start_inc+step_inc*nb_divz
			surf1[inc],surf2[inc]=pos_surf(start_inc, end_inc, step_inc, rho,divz)
			#print(start_inc, step_inc, end_inc)
			#print(surf1[inc],surf2[inc])
			inc += 1

#==================================================
#Determine the atoms which are close to the surface
#and print their index
#==================================================
file_o1.write('surface 1:\n')
for at in range(nb_atoms):
	if lsymb[at].number == 8:
		good_O=False #Test value, to know if the studied O is good 
		test_Os=-1
		#Conversion of the (y,z) coordinates of O into (j,k)
		i=math.floor(lx[at]/divx)
		j=math.floor(ly[at]/divy)
		k=math.floor(lz[at]/divz)

		if n_axis ==0:
			#Comparison between the distance of O to surf1 with the default thickness
			#if the O is close to the surface, then we print it
			if surf1[nb_divz*j+k]+thickness >= lx[at]:
				for at1 in range(nb_atoms): 
					# The following two lines (for... if...) are used to extract O atoms' indices with O-H bond.
					# the criterion for judging the existence of O-H bond
					if (lx[at1]-lx[at])**2 + (ly[at1]-ly[at])**2 +(lz[at1]-lz[at])**2 <= max_dist2_no and lsymb[at1].number ==1:
						if at!=test_Os:
							file_o1.write(str(at+1)+' ')
							print (at+1, " ", end="")
							good_O=True
							test_Os=at

		elif n_axis ==1:
			if surf1[nb_divz*i+k]+thickness >= ly[at]:
				for at1 in range(nb_atoms):
					if (lx[at1]-lx[at])**2 + (ly[at1]-ly[at])**2 +(lz[at1]-lz[at])**2 <= max_dist2_no and lsymb[at1].number ==1:
						if at!=test_Os:
							file_o1.write(str(at+1)+' ')
							print (at+1, " ", end="")
							good_O=True
							test_Os=at
		else:
			if surf1[nb_divy*i+j]+thickness >= lz[at]:
				for at1 in range(nb_atoms):
					if (lx[at1]-lx[at])**2 + (ly[at1]-ly[at])**2 +(lz[at1]-lz[at])**2 <= max_dist2_no and lsymb[at1].number ==1:
						if at!=test_Os:
							file_o1.write(str(at+1)+' ')
							print (at+1, " ", end="")
							good_O=True
							test_Os=at


		#If the O is close to the surface (good_O=True)
		#Therefore, the H close to him are printed too             
		if good_O:
			for at2 in range(nb_atoms):                                    
				if lsymb[at2].number ==1: 
					if (lx[at2]-lx[at])**2 + (ly[at2]-ly[at])**2 +(lz[at2]-lz[at])**2 <= max_dist2:                                                                
						file_o1.write(str(at2+1)+' ')
						print(at2+1, " ", end=" ")
file_o1.write('\nsurface 2:\n')
print()
for at in range(nb_atoms):
	if lsymb[at].number == 8:
		good_Os=False #Test value, to know if the studied O is good 
		test_Os=-1
		#Conversion of the (y,z) coordinates of O into (j,k)
		i=math.floor(lx[at]/divx)
		j=math.floor(ly[at]/divy)
		k=math.floor(lz[at]/divz)

		if n_axis ==0:
			#Comparison between the distance of O to surf2 with the default thickness
			#if the O is close to the surface, then we print it
			if surf2[nb_divz*j+k]-thickness <= lx[at]:
				for at1 in range(nb_atoms): # The following two lines (for... if...) are used to extract O atoms' indices with O-H bond.
					if (lx[at1]-lx[at])**2 + (ly[at1]-ly[at])**2 +(lz[at1]-lz[at])**2 <= max_dist2_no and lsymb[at1].number ==1:
						if at!=test_Os:
							file_o1.write(str(at+1)+' ')
							print (at+1, " ", end="")
							good_Os=True
							test_Os=at

		elif n_axis ==1:
			if surf2[nb_divz*i+k]-thickness <= ly[at]:
				for at1 in range(nb_atoms): # The following two lines (for... if...) are used to extract O atoms' indices with O-H bond.
					if (lx[at1]-lx[at])**2 + (ly[at1]-ly[at])**2 +(lz[at1]-lz[at])**2 <= max_dist2_no and lsymb[at1].number ==1:
						if at!=test_Os:
							file_o1.write(str(at+1)+' ')
							print (at+1, " ", end="")
							good_Os=True
							test_Os=at
		else:
			if surf2[nb_divy*i+j]-thickness <= lz[at]:
				for at1 in range(nb_atoms): # the useness is the same as obove 
					if (lx[at1]-lx[at])**2 + (ly[at1]-ly[at])**2 +(lz[at1]-lz[at])**2 <= max_dist2_no and lsymb[at1].number ==1:
						if at!=test_Os:
							file_o1.write(str(at+1)+' ')
							print (at+1, " ", end="")
							good_Os=True
							test_Os=at


		#If the O s close to the surface (good_Os=True)
		#Therefore, the H close to him are printed too             
		if good_Os:
			for at2 in range(nb_atoms):                                    
				if lsymb[at2].number ==1: 
					if (lx[at2]-lx[at])**2 + (ly[at2]-ly[at])**2 +(lz[at2]-lz[at])**2 <= max_dist2:                                                                
						file_o1.write(str(at2+1)+' ')
						print(at2+1, " ", end=" ")
file_o1.write('\n')
print()

file_o1.write('\nbulk:\n')
print()
for at in range(nb_atoms):
		if lsymb[at].number == 8:
			good_Os=False #Test value, to know if the studied O is good 
			test_Os=-1
			#Conversion of the (y,z) coordinates of O into (j,k)
			i=math.floor(lx[at]/divx)
			j=math.floor(ly[at]/divy)
			k=math.floor(lz[at]/divz)
	
			if n_axis ==0:
				#Comparison between the distance of O to surf1 and surf2 with the default thickness
				#if the O is far away from the surfaces, then we print it
				if surf1[nb_divz*j+k]+thickness <= lx[at] and surf2[nb_divz*j+k]-thickness >= lx[at]:
					for at1 in range(nb_atoms):
						if (lx[at1]-lx[at])**2 + (ly[at1]-ly[at])**2 +(lz[at1]-lz[at])**2 <= max_dist2_no and lsymb[at1].number ==1:
							if at!=test_Os: # to remove the repeated atomic indices coming from the max_dist2_no criterion. 
								file_o1.write(str(at+1)+' ')
								print (at+1, " ", end="")
								good_Os=True # If there exists a H-O bond for an O atom which is far way from any of the surfaces, print the index of the O atom
								test_Os=at

			elif n_axis ==1:
				if surf1[nb_divz*i+k]+thickness <= ly[at] and  surf2[nb_divz*i+k]-thickness >= ly[at]:
					for at1 in range(nb_atoms):
						if (lx[at1]-lx[at])**2 + (ly[at1]-ly[at])**2 +(lz[at1]-lz[at])**2 <= max_dist2_no and lsymb[at1].number ==1:
							if at!=test_Os:
								file_o1.write(str(at+1)+' ')
								print (at+1, " ", end="")
								good_Os=True
								test_Os=at
			else:
				if surf1[nb_divy*i+j]+thickness <= lz[at] and surf2[nb_divy*i+j]-thickness >= lz[at]:
					for at1 in range(nb_atoms):
						if (lx[at1]-lx[at])**2 + (ly[at1]-ly[at])**2 +(lz[at1]-lz[at])**2 <= max_dist2_no and lsymb[at1].number ==1:
							if at!=test_Os:
								file_o1.write(str(at+1)+' ')
								print (at+1, " ", end="")
								good_Os=True
								test_Os=at


			#If the O s close to the surface (good_Os=True)
			#Therefore, the H close to him are printed too             
			if good_Os:
				for at2 in range(nb_atoms): 
					if lsymb[at2].number ==1: 
						if (lx[at2]-lx[at])**2 + (ly[at2]-ly[at])**2 +(lz[at2]-lz[at])**2 <= max_dist2:                                                                
							file_o1.write(str(at2+1)+' ')
							print(at2+1, " ", end=" ")
file_o1.write('\n')
print()
 \end{lstlisting}
%\end{widetext}
%============

\section{Free energy calculation}  \label{free_energy}
To make sure we start from the right configuration in the vapor-liquid interface system and to explain the calcualted VDOS of the water molecules in the interface,we study the interface from the view of free energy.

For a NVT ensemble, the most stable state is the one with the lowest free energy. We will find out different configurations which have minimum free energies.

In the system of the interface, the relation between free energies of different configurations can give us the explaination of the vibrational properties of water molecules. 
Consider a cluster including an alkali metal cation,a nitrate anion and more water: LiNO$_3$(H$_2$O)$_{30}$.
The blue-moon ensemble method\cite{EAC89,MS98,MET10} is used to calculate the free energy as a function of a parameter: 
the distance $r$ between alkali metal cation and the nitrogen of \nitrate  in LiNO$_3$(H$_2$O)$_{30}$.
In Fig.~\ref{fig:Li-nitrate-32w_free-ener}, we find that there are two minimum in the free energy at $r=2.9$ \AA\ (configuration A)  and $r=4.3$ \AA \ (configuration B).
\Li and \nitrate are bonded in configuration A, but are separated in configuration B.
The free energy difference $\Delta{F}_{AB}=F_A-F_B$= 0.3 kcal/mol. 
We use C denotes the transition state. 
The energy barrier between C and A (B) is:
$\Delta{F_{CA}}$= 1.2kcal/mol ($\Delta{F_{CB}}$= 1.5kcal/mol). Configuration B is stable than A. This result interprets the probability that the system is in configuration B is larger than in A. For the water molecules in interface system, \nitrate resides on the surface and \Li in the layer below, separated from \nitrate  by water molecules. Therefore, no obvious redshift  induecd by alkali metal cation and nitrate is obtained in the SFG spectrum.

\section{Testing the program for calculating dipole distribution}
For testing the program, we use the trajectory of the water molecules from the classical Molecular Dynamics (MD) to calculate the dipole tilt angle.
\begin{figure}
\centering
\includegraphics [width=0.6\textwidth]{./diagrams/dipole_orien_128w}   % Here is how to import EPS art
\setlength{\abovecaptionskip}{10pt}
\caption{\label{fig:bulk} The diple moment orientation for water molecules in bulk water. The number of bins $n=72$.}
\end{figure}

Fig.\ref{fig:bulk} shows the dipole moment orientation distribution of all the water molecules.  
It is a sine-like function.
We assume that the system is isotropic, then the dipole moment will be distributed uniformly in any direction ($\theta,\phi$). The probability density
$P(\theta,\phi)=1/{4\pi}$.The probability that the dipole moment is point
to the area element $\text{d}\theta\text{sin}\theta\text{d}\phi$ in the direction ($\theta,\phi$) is 
\begin{equation}
P(\theta,\phi)\text{d}\theta\text{sin}\theta\text{d}\phi\nonumber,
\label{eq:6}
\end{equation}
thus the probability that the dipole moment is pointing to the direction in the internal ($\theta,\theta+\text{d}\theta$) is
\begin{equation}
P(\theta)\text{d}\theta=\frac{1}{4\pi}\int_0^{2\pi}\text{d}\phi\text{d}\theta\text{sin}\theta=\frac{1}{2}\text{sin}\theta\text{d}\theta.\nonumber
\label{eq:7}
\end{equation}
Therefore, the probability density is $P(\theta)=\frac{1}{2}\text{sin}\theta$. From the Fig.~\ref{fig:bulk}, we find that the resulting $P(\theta)$ is indeed a sine function. If we have chosen $n$ bins to plot the histogram,
then the width of each bin is ${2\pi}/n$, and the maximum will be
\begin{equation}
P(\pi/2)=1\times\frac{2\pi}{n}.
\label{eq:8}
\end{equation}
For example, if $n=72$, the maximum probability should be 
$P(\pi/2)=0.087$ (fig.\ref{fig:bulk}).
Our simulation fits this result well. So our program for calculating the dipole moment orientation works well.

For a longer MD trajectory, we repeat the calculation. Thus we have the comparison of the dipole orientation distribution between 
the long and the short MD trajectories.

Now we calculate the O-H group orientation distribution of the water molecules with similar mehod.
This is a natural result of fluctuations. The main reason for no probability in small $\theta$'s is
that here we did not consider the integration of the angle $\phi$ and that the sample points is sam (less than 100 values).

\section{HB Population Operator Auto-Correlation Function}
\begin{lstlisting}[
                  language=fortran]                  ]
!=================
!function: hbacf2.f95
!=================
!==================================================
!For any pairs of water molecules, we can calculate the 
!average of h(t) and autocorrelation function S_HB(t),S_d_HB(t),
!C_HB(t),C_d_HB(t)。
!      
! C_{HB}(t)= <h(0)h(t)>/<h>
! C^(d)_{HB}(t)= <h(0)h^(d)(t)>/<h>
!===================================================
     ! input file: input
     ! name of system
     ! name of trajectory
     ! name of list
     ! nmo
     ! nat
     ! number of pairs of molecules(np) 
!===============
      program hbacf2
      implicit none
!===============
!==========
!parameters
!==========
      character(LEN=30) :: filename ,pos_filename,list_filename         
      integer,parameter :: rk=4              
      integer,parameter :: nmax=2001 ! max number of atoms
      integer,parameter :: nmo_max=300000 ! max number of movie
      real(kind=rk),parameter :: rate=0.50 ! condition for cutting off autocorrelation functions
      real,parameter :: rooc=29.16 ! cutoff distance of rOO (5.4**2 )
      real,parameter :: rohc=12.25 ! rOH (3.5**2)
      real,parameter :: cosphic=0.866 ! 1.732/2; phiC=pi/6.
      real(kind=rk),parameter :: hb_min=0.0000001 ! condition for the existence of h-bond
      real(kind=rk),parameter :: delta_t=0.01 ! ps
      real(kind=rk)           :: r12,r13,r23,cosphi,pm,qj,qj_d,&
                                 tot_hb
      integer :: begin_time,end_time,rat,i,j,k,jj,nmo,nat,iatom,& 
                 imovie,np,m1,m2,m3,mt 
      real(kind=rk),allocatable,dimension (:)    :: h,h_d
      real(kind=rk),allocatable,dimension (:)    :: hb,hb_d
      real,allocatable,dimension (:,:)           :: x,y,z
      character(LEN=3)  :: atom_type  ! we are not interested in the atom type in this calculation, thus I do not use allocatable array for it.
      integer,allocatable,dimension(:)           :: ndx_1, ndx_2, ndx_3
      real(kind=rk),allocatable,dimension (:)    :: corr_h, corr_h_d
      real(kind=rk)  :: scalar, scalar_d 
      call system_clock(begin_time,rat)
!==================
!read data in input
!==================
      write(6,*)'What is the name of the system:'
      read(5,*)filename
      write(6,*)'What is the name of the trajecotry file:'
      read(5,*)pos_filename     
      write(6,*)'What is the name of thei list file:'
      read(5,*)list_filename     
      write(6,*)'What is the total steps of the trajecotry:'
      read(5,*)nmo  !number of movie steps
      write(6,*)'What is the total number of atoms in the system:'
      read(5,*)nat  !number of atoms per mole.
      write(6,*)'What is the total number of water pairs:'
      read(5,*)np   !number of pairs   

      allocate(ndx_1(np))          
      allocate(ndx_2(np))          
      allocate(ndx_3(np))          

      if (nmo >= nmo_max)then
        write(6,*)'!! nmo> nmo_max !!'
        write(6,*)'!! stop !!'
        stop
      endif
      
      if (nat >= nmax)then
        write(6,*)'!! nat> nmax !!' 
        write(6,*)'!! stop !!'
        stop
      endif  

      list_filename=trim(list_filename)
      open(10,file=list_filename)     
      do k=1,np
          read(10,*)ndx_1(k),ndx_2(k),ndx_3(k)
      enddo
      close(10)

      allocate(x(nat,nmo))
      allocate(y(nat,nmo))
      allocate(z(nat,nmo))
      allocate(h(nmo))
      allocate(h_d(nmo))
      allocate(hb(np))  !Average H-bonded population 
      allocate(hb_d(np))

!=======================
!read in trajectory file 
!=======================
      open(10,file=trim(pos_filename))     
      do imovie=1,nmo
         read(10,*)  !Neglect data of this line
         read(10,*)                 
         do iatom= 1,nat
             read (10,*)atom_type,x(iatom,imovie),y(iatom,imovie),&
                        z(iatom,imovie)
         enddo
      enddo
      close(10)
      write(6,*) 'end of trajectory reading'
!======================
      allocate(corr_h(nmo))
      allocate(corr_h_d(nmo))
!==================================
!Calculate autocorrelation function
!==================================

      ! calculate <h(0)h(t)>/<h> and 
      ! calculate <h^d(0)h^d(t)>/<h^d> 
      ! Notice here <> is not average over
      ! different pairs of water molecules,
      ! but average over the time steps.
      do i=1, nmo
        corr_h(i)=0.0
        corr_h_d(i)=0.0
      enddo
      
      tot_hb=0.0
      do k=1,np
          hb(k)=0.0
          hb_d(k)=0.0
      enddo

      do k=1,np
      !calculate h(j)
        qj=0
        qj_d=0
        m1=ndx_1(k)
        m2=ndx_2(k)
        m3=ndx_3(k)
        
        do jj =1, nmo
          h(jj)=0
          h_d(jj)=0 
          r13= (x(m1,jj)-x(m3,jj))**2+       &
                    (y(m1,jj)-y(m3,jj))**2+  &
                    (z(m1,jj)-z(m3,jj))**2  !r:squra of distances
          r12= (x(m1,jj)-x(m2,jj))**2+       &
                    (y(m1,jj)-y(m2,jj))**2+  &
                    (z(m1,jj)-z(m2,jj))**2
          r23= (x(m2,jj)-x(m3,jj))**2+       &
                    (y(m2,jj)-y(m3,jj))**2+  &
                    (z(m2,jj)-z(m3,jj))**2
          pm= (x(m3,jj)-x(m2,jj))*           &
                   (x(m1,jj)-x(m2,jj))+      & 
                   (y(m3,jj)-y(m2,jj))*      & 
                   (y(m1,jj)-y(m2,jj))+      & 
                   (z(m3,jj)-z(m2,jj))*      &
                   (z(m1,jj)-z(m2,jj)) 
          cosphi= pm/(sqrt(r23*r12)) !pm: point multiplication.
          if (r13 .lt. rohc .and. r12 .lt. rooc   & 
             .and. cosphi .gt. cosphic) then    
              h(jj)=1.0 
              qj=qj+h(jj)                          
          endif
          if (r13 .lt. rohc ) then                           
              h_d(jj)=1.0
              qj_d=qj_d+h_d(jj)                          
          endif
        enddo   
        qj=qj/nmo ! ave of hb for each pair 
        qj_d=qj_d/nmo
        hb(k)=qj
        hb_d(k)=qj_d
        tot_hb=tot_hb+hb(k)

        do mt=0,nmo-1     ! time interval
            if(hb(k)>hb_min) then
                scalar=0.d0
                do j=1, nmo-mt-1
                    scalar=scalar+h(j)*h(j+mt)  ! 1: the first pair of water molecules
                enddo
                scalar=scalar/(nmo-mt-1)  ! C_k(t)
                corr_h(mt+1)=corr_h(mt+1)+scalar  ! sum_C_k(t)
            endif
        enddo
        do mt=0,nmo-1 ! time interval
            if(hb_d(k)>hb_min) then
                scalar_d=0.d0
                do j=1, nmo-mt-1
                    scalar_d=scalar_d+h(j)*h_d(j+mt) ! 1: the first pair of water molecules
                enddo
                scalar_d=scalar_d/(nmo-mt-1) ! C_k(t)
                corr_h_d(mt+1)=corr_h_d(mt+1)+scalar_d  ! sum_C_k(t)
            endif
        enddo

      enddo ! k loop 
      tot_hb=tot_hb/np

      do mt=0,nmo-1 ! time interval
          corr_h(mt+1)=corr_h(mt+1)/(np*tot_hb)  
          corr_h_d(mt+1)=corr_h_d(mt+1)/(np*tot_hb)  
      enddo

      deallocate(x,y,z)
      deallocate(ndx_1,ndx_2,ndx_3)          
 
!===================================
!Write the correlation C_HB(t) and C_HB_d(t)     
!===================================
      open(10,file=trim(filename)//'_Chandra_achbond_h.dat')
        do i=1,int(nmo*rate)
            write(10,*)(i-1)*delta_t,corr_h(i)
        enddo
        write(6,*)'written in '//trim(filename)//&
                  '_Chandra_achbond_h.dat'
      close(10)

      open(10,file=trim(filename)//'_Chandra_achbond_h_d.dat')
        do i=1,int(nmo*rate)
            write(10,*)(i-1)*delta_t,corr_h_d(i)
        enddo
        write(6,*)'written in '//trim(filename)//&
                  '_Chandra_achbond_h_d.dat'
      close(10)

!=======================================
!Write the correlation ln(C_HB(t)) and lnC_HB_d(t)     
!=======================================
      open(10,file=trim(filename)//'_Chandra_achbond_ln_h.dat')
        do i=1,int(nmo*rate)
            write(10,*)(i-1)*delta_t,log(corr_h(i))
        enddo
        write(6,*)'written in '//trim(filename)//&
                  '_Chandra_achbond_ln_h.dat'
      close(10)

      open(10,file=trim(filename)//'_Chandra_achbond_ln_h_d.dat')
        do i=1,int(nmo*rate)
            write(10,*)(i-1)*delta_t,log(corr_h_d(i))
        enddo
        write(6,*)'written in '//trim(filename)//&
                  '_Chandra_achbond_ln_h_d.dat'
      close(10)
!----------      
! print <h>      
!----------      
      open(10,file=trim(filename)//'_Chandra_average_h.dat')
        write(10,*) '<h>:',tot_hb
        write(6,*)'written in '//trim(filename)//&
                  '_Chandra_average_h.dat'
      close(10)

      deallocate (h,h_d,corr_h,corr_h_d)
!==============================================================
      call system_clock(end_time,rat)
      write(6, *)"elapsed time: ", real(end_time-begin_time)/real(rat) 
      END
\end{lstlisting}

For a given system, the list file gives all the pairs of molecules which may hydrogen bonded.  Each line in the file include three index of O or H atom in a pair of molecules, which may H-bonded. It provides all the pairs of molecules that may H-bonded. For example, for the cluster LiNO$_3$(H$_2$O)$_3$ (fig.~\ref{fig:nitrate_alkali_cluster_1}(b)), there are three water molecules ($N_{\text{water}}$=3) and three nitrate O atoms ($N_{\text {nitrate O}}=3$).  The possible H bonds $N_{\text HB}$ for this system is
\begin{equation}
N_{\text{HB}}=2N_{\text{water}} [N_{\text {nitrate O}}+ (N_{\text{water}}-1)],
\label{N_HB}
\end{equation}
where the factor 2 stems from the fact that there are two H atoms in a water molecule.
Thus, $N_{\text HB}$=30 for the system LiNO$_3$(H$_2$O)$_3$. The list file is as follows.
% backgroundcolor=\color{lightgray},
\begin{lstlisting}[
                  language=fortran]                  
! filename: LiNO3-3w_list.dat
! 1st column: O (nitrate O, or water O)
! 2nd column: O (water O)
! 3rd column: H (water H)
           2           5           6
           3           5           6
           4           5           6
           8           5           6
          11           5           6
           2           5           7
           3           5           7
           4           5           7
           8           5           7
          11           5           7
           2           8           9
           3           8           9
           4           8           9
           5           8           9
          11           8           9
           2           8          10
           3           8          10
           4           8          10
           5           8          10
          11           8          10
           2          11          12
           3          11          12
           4          11          12
           5          11          12
           8          11          12
           2          11          13
           3          11          13
           4          11          13
           5          11          13
           8          11          13
\end{lstlisting}

\paragraph{ACKNOWLEDGMENT}

I wish to express my sincere gratitude to my supervisors, Prof. Dr. Marilore Sulpizi for her excellent
guidance and help during my research. I wish to thank  Prof. Dr. Thomas K$\ddot{\text u}$hner, Dr. Giovanni Settanni, Dr. Peter Virnau, Dr. Hans Behringer, Prof. Dr. Thomas Speck  and  in the Institute for Physik for leading me to the fundamental statistical physics and excellent lectures and discussions. I am grateful to Prof. Dr. Friederike Schmid and  Prof. Dr. Kurt Binder for their talks and guidance.

I am grateful to Dr. R\'{e}mi Khatib for programing skills and helpful guidance on the programs for calculating SFG and Extracting isosurface. I also thank Dr. Fei Yu for useful discussions on the the calculation of response functions.
I would like to thank my numerous friends at the Institute f$\ddot{\text u}$r Physik, especially
my fellow students in the Prof. Dr. Sulpizi's Group, for their encouragement and assistance.
I am grateful to my family for being there for me during the last years. 

The financial supports of the China Scholarship Council and TRR146 is gratefully acknowledged. 
